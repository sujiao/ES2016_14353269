# LAB11_FunctionalDebugging

---

## 一、Keil简介 ##
Keil 是美国Keil Software 公司出品的51系列兼容单片机C语言软件开发系统，与汇编相比，C语言在功能上、结构性、可读性、可维护性上有明显的优势，因而易学易用。Keil提供了包括C编译器、宏汇编、链接器、库管理和一个功能强大的仿真调试器等在内的完整开发方案，通过一个集成开发环境（μVision）将这些部分组合在一起。运行Keil软件需要WIN98、NT、WIN2000、WINXP等操作系统。如果使用C语言编程，那么Keil几乎就是不二之选，即使不使用C语言而仅用汇编语言编程，其方便易用的集成环境、强大的软件仿真调试工具也会事半功倍。其可实现的额部分功能如下如所示。
    ![Keil][1]
    
Keil优点：
    生成的目标代码效率非常之高，多数语句生成的汇编代码很紧凑，容易理解。在开发大型软件时更能体现高级语言的优势。与汇编相比，C语言在功能上、结构性、可读性、可维护性上有明显的优势，因而易学易用。用过汇编语言后再使用C来开发，体会更加深刻。
    
---
## 二、Keil调试器的安装 ##
解压安装包，点击MDK474.EXE，一路next安装，安完之后有提示安装驱动，也点安装。然后点击EE319K_InstallSpring2016.exe，一路next安装即可。如下面两图所示。
![1][2]
![2][3]

---
## 三、任务 ##

 - 熟悉Keil调试器的使用;
 - 运行代码，观察Registers和Memory的值的变化;
 - 找出Cnt变量的最终值和HappyBuf的最终值，并截图。实验报告需给出该截图，并解释如何得出结论。

---
## 四、实验步骤 ##

 1. 打开工程
    解压FunctionalDebugging.zip，点击Project->Open Project，选择解压好的路径下FunctionalDebugging文件夹中的.uvproj文件，可以看到两个.s文件，Startup.s和main.s。Startup.s：完成基本的CPU初始化，如果有必要，这里也对外围的设备进行初始化；main.s：主体程序，执行完Startup.s后，跳转到Start。
        
 2. 程序简介
    main.s程序有两个缓冲区HappyBuf和SadBuf，程序将sad和happy两个8位变量赋为随机数，再将这两个变量转存到数组中。Cnt保存数组偏移量，Cnt被初始化为0，转存时先判断Cnt是否越界，若否，则将变量转存再将Cnt加1。

 3. 开始调试器
点击Debug->Start/Stop Debug Session，启动调试器。在调试状态，
Debug菜单项中的命令可以使用了，有关编译的工具栏按钮消失了，出现了一个用于运行和调试的工具栏，Debug 菜单上的大部份命令都有相应的快捷按钮。
![此处输入图片的描述][4]

 4. 调试及分析
首先将每一个调试Debug工具按钮都使用一遍，为之后的调试做准备。然后使用单步跟踪观察每一条指令运行情况，充分理解代码含义。最后点击复位，运行，打开寄存器窗口，观察窗口和内存窗口，观察最后的运行结果如下所示。

![此处输入图片的描述][5]
    
        首先，Cnt变量的最终值为绿色字体，0x00000014即20，与实验预期一致；HappyBuf的最终值为上面第一行红色框标出的区域，BadBuf的最终值为上面第二行红色框标出的区域。
        因为Sad和Happy是8位二进制数，32位寄存器表示为16进制后，每一位表示了4位二进制数，所以两位可表示这样一个Sad或者Happy。如下图所示，因为代码中在Cnt等于20后，程序在循环loop中不断执行，不断生成32位随机数存在R0中，并取低8位赋给Sad和Happy。由下面的代码可以看出，先取随机数赋给Sad，然后是Happy，所以一次循环后，R0中的值存在内存中R2值表示的位置，而该值的最后两位为Happy。上图的最后两个框也展现了该点。

![此处输入图片的描述][6]![此处输入图片的描述][7]

        由前面的分析可知，R2中值指向的位置储存生成的随机数，如下图蓝色框所示，可以看出0x2000002C位置在前面的内存图中储存的值确实是loop循环中的第二个随机数，R4，R5中地址对应到内存图也是Sad和Happy的值。
        
        
![此处输入图片的描述][8]
        
        最后，根据下面的观察串口也可以看出前面的分析和结论是正确的。由于Loop循环一直在执行，Sad和Happy对应的值一直在不停的变化，此处截了两张图表现该现象，该现象也符合实验预期。最后由于uint是32位二进制数，所以HappyBuf只显示了前面四位，与前面的内存图比较可以看出结果正确。
![此处输入图片的描述][9]
![此处输入图片的描述][10]

至此，分析完毕，可以看出前面的结论是正确的！

---


  [1]: http://i1.piimg.com/567571/0a6a8bfc33204314.png
  [2]: http://p1.bpimg.com/567571/83050cc4da0952f8.png
  [3]: http://p1.bpimg.com/567571/a2741fd64ad8bc52.png
  [4]: http://i1.piimg.com/567571/b868095a40ae87d5.png
  [5]: http://p1.bqimg.com/567571/4d3043659849fbe3.png
  [6]: http://p1.bqimg.com/567571/f2a437da9350f6bc.png
  [7]: http://p1.bqimg.com/567571/355f05a658fdab8a.png
  [8]: http://p1.bpimg.com/567571/290caf95bdfd98e6.png
  [9]: http://p1.bpimg.com/567571/f346c0c6519ee94d.png
  [10]: http://p1.bpimg.com/567571/3e9d5bd4fc5b61cc.png